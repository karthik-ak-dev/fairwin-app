/**
 * VRF Callback Service
 *
 * Handles Chainlink VRF fulfillment callbacks.
 * Processes random number and triggers winner selection.
 */

import { verifyMessage } from 'viem';
import { raffleRepo } from '@/lib/db/repositories';
import * as raffleDrawService from '../raffle/raffle-draw.service';
import { VRFRequestError } from '../errors';
import { getVRFRequestStatus } from './contract-read.service';

/**
 * Process VRF fulfillment callback
 *
 * Called by Chainlink when random number is ready.
 * Triggers winner selection for the raffle.
 *
 * @param requestId VRF request ID from Chainlink
 * @param randomNumber Random number generated by VRF
 *
 * @throws VRFRequestError if verification fails
 */
export async function handleVRFFulfillment(
  requestId: string,
  randomNumber: bigint,
  chainId: number = 137
): Promise<void> {
  // Verify request on-chain
  const vrfStatus = await getVRFRequestStatus(requestId, chainId);

  if (!vrfStatus.fulfilled) {
    throw new VRFRequestError('VRF request not fulfilled on-chain');
  }

  if (vrfStatus.randomNumber !== randomNumber) {
    throw new VRFRequestError('Random number mismatch');
  }

  // Find raffle with this VRF request ID
  const raffle = await findRaffleByVRFRequest(requestId);

  if (!raffle) {
    throw new VRFRequestError(`No raffle found for VRF request: ${requestId}`);
  }

  // Verify raffle is in drawing status
  if (raffle.status !== 'drawing') {
    throw new VRFRequestError(
      `Raffle ${raffle.raffleId} is not in drawing status (current: ${raffle.status})`
    );
  }

  // Complete the draw using the random number
  await raffleDrawService.completeRaffleDraw(raffle.raffleId, randomNumber);
}

/**
 * Verify VRF callback authenticity
 *
 * Validates that the callback came from Chainlink VRF coordinator
 *
 * Note: This is a defense-in-depth measure. The primary security is enforced
 * on-chain by the VRF contract itself, which only accepts callbacks from the
 * authorized VRF coordinator.
 *
 * @param requestId VRF request ID
 * @param signature Callback signature (ECDSA signature as hex string)
 * @param coordinatorAddress Expected VRF coordinator address
 * @returns true if valid, false otherwise
 */
export async function verifyVRFCallback(
  requestId: string,
  signature: string,
  coordinatorAddress: string
): Promise<boolean> {
  // Basic validation
  if (!requestId || requestId.length === 0) {
    return false;
  }

  if (!signature || signature.length === 0) {
    return false;
  }

  try {
    // Verify ECDSA signature
    const isValid = await verifyMessage({
      address: coordinatorAddress as `0x${string}`,
      message: requestId,
      signature: signature as `0x${string}`,
    });

    return isValid;
  } catch {
    // Signature verification failed
    return false;
  }
}

/**
 * Find raffle by VRF request ID
 *
 * Scans drawing raffles to find one with matching VRF request
 */
async function findRaffleByVRFRequest(requestId: string) {
  // Get all raffles in drawing status
  const result = await raffleRepo.getByStatus('drawing');
  const drawingRaffles = result.items;

  // Find raffle with matching VRF request ID
  return drawingRaffles.find((r) => r.vrfRequestId === requestId) || null;
}
